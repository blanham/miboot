/* This code fragments provides the low-level 68k boot code   with some PPC functions (necessary for using the name   registry API for example). */ #include <PCI.h>#include <Errors.h>#include <MixedMode.h>#include <CodeFragments.h>#include <Gestalt.h>#include <NameRegistry.h>#include "BootX.h"#include "LowLevelBoot.h"#include "debug_text.h"#define DEBUG	0#ifndef BROKEN_THIRD_PARTY_CARDS#define BROKEN_THIRD_PARTY_CARDS	1#endif#define MAX_STRING_PROP_SIZE	256#define MAX_ASSIGNED_ADDRESSES	8#define	kPCIConfigCommandAddress		0x04		/* PCI "Command" config register address	*/#define		cwCommandEnableMemorySpace	0x0002		/*   enable memory space bit */#define		cwCommandEnableIOSpace		0x0001		/*   enable i/o space bit *//* Exported */extern pascal void* main(void);extern pascal void ShutDownDevices(dt_context *in_dct, boot_infos_t* bi);UInt32 __procinfo = kPascalStackBased | RESULT_SIZE(SIZE_CODE(sizeof(void*)));typedef void (*iterate_device_proc)(RegEntryIDPtr entryID);static OSErr	iterate_devices(iterate_device_proc	proc);static SInt32	read_pci_config_reg(RegEntryIDPtr entryID, int reg);static UInt32	get_assigned_addresses(RegEntryIDPtr entryID, PCIAssignedAddress* outAddresses);static void		get_string_property(RegEntryIDPtr entryID, char* prop_name, char *out_string);static UInt32	get_io_addresses(RegEntryIDPtr entryID, UInt32 *out_addresses);static Boolean	check_vendor_device_id(RegEntryIDPtr entryID, UInt16 vendorID, UInt16 deviceID);static OSStatus	get_one_property(	RegEntryIDPtr			regEntryIDPtr,									RegPropertyNamePtr		regPropertyName,									RegPropertyValue		*regPropertyValuePtr,									RegPropertyValueSize	*regPropertyValueSizePtr);static void		reset_apple_SCSI_UW_board(RegEntryIDPtr entryID);static void		reset_apple_DBDMA_channels(RegEntryIDPtr entryID);static void		reset_apple_USB(RegEntryIDPtr entryID);static void		reset_ATI_mach64_master(RegEntryIDPtr entryID);static void		remap_PDM_video(void);static dt_context *dct;UInt32 strlen(char * s) {	const char *sc;	for (sc = s; *sc != '\0'; ++sc) ;	return sc - s;}void memset(void *p, int c, UInt32 s) {	while(s--)		((char *)p)[s] = (char)c;}void memcpy(void* d, void* s, UInt32 z) {	BlockMove(s,d,z); /* BlockMoveData ? */}void memmove(void* d, void* s, UInt32 z) {	BlockMove(s,d,z); /* BlockMoveData ? */}int strcmp(const char * cs,const char * ct) {	char __res;	while (1) {		if ((__res = *cs - *ct++) != 0 || !*cs++)			break;	}	return __res;}char * strcat(char * dest, const char * src) {	char *tmp = dest;	while (*dest) dest++;	while ((*dest++ = *src++) != '\0') ;	return tmp;}int strncmp(const char * cs,const char * ct,UInt32 count){	char __res = 0;	while (count) {		if ((__res = *cs - *ct++) != 0 || !*cs++)			break;		count--;	}	return __res;}RoutineDescriptor	g_desc = BUILD_ROUTINE_DESCRIPTOR(uppLowLevelBootPPCProcInfo, ShutDownDevices);pascal void*main(void){//	return (void *)NewRoutineDescriptor((ProcPtr)ShutDownDevices, uppLowLevelBootPPCProcInfo, kPowerPCISA);	return &g_desc;}pascal voidShutDownDevices(dt_context *in_dct, boot_infos_t* bi){	dct = in_dct;		dt_printf(dct, "Shutting down devices...\n");		/* NuBus: Change address of PDM framebuffer */	if ((long)RegistryEntryIDInit == kUnresolvedCFragSymbolAddress) {		dt_printf(dct, "No name registry !\n");		if (bi->architecture & BOOT_ARCH_NUBUS_PDM) {			/* This should definitely be smarter !!! */			if ((UInt32)bi->dispDeviceBase <= 0x100000) {				int i;				remap_PDM_video();				bi->logicalDisplayBase = (UInt8*)0x100000;				bi->dispDeviceBase = (UInt8*)0x100000;				for(i=0; i<bi->physMemoryMapSize; i++) {					if ((bi->physMemoryMap[i].physAddr <= (UInt32)bi->dispDeviceBase) &&						((bi->physMemoryMap[i].physAddr + bi->physMemoryMap[i].size)							> (UInt32)bi->dispDeviceBase)) {						int count = bi->physMemoryMapSize;						int size = bi->physMemoryMap[i].size;						memmove(&bi->physMemoryMap[i+1], &bi->physMemoryMap[i],							sizeof(boot_info_map_entry_t) * (count-i-1));						bi->physMemoryMap[i].size = (UInt32)bi->dispDeviceBase - bi->physMemoryMap[i].physAddr;						bi->physMemoryMap[i+1].physAddr = (UInt32)bi->dispDeviceBase + 0x100000;						bi->physMemoryMap[i+1].size = (size + bi->physMemoryMap[i].physAddr - bi->physMemoryMap[i+1].physAddr);						break;					}				}					}		}	} else {		/* PCI: Disable DMA on known devices */		iterate_devices(reset_apple_SCSI_UW_board);		iterate_devices(reset_apple_DBDMA_channels);		iterate_devices(reset_apple_USB);		iterate_devices(reset_ATI_mach64_master);	}}#if BROKEN_THIRD_PARTY_CARDSinline asm fixed_eieio(void) {	li r0,0;	cmpwi r0,0;	bne+ toto;	eieio;	toto:;}#else#define fixed_eieio()	__eieio()#endifstatic voidremap_PDM_video(void){	unsigned char savevalue[35];	int i;		*((volatile unsigned char *)0x50F40008) = 0;	/* reset bit counter */	fixed_eieio();	for (i=0; i<35; i++) {		savevalue[i] = *((volatile unsigned char *)0x50F40000);		fixed_eieio();	}	savevalue[33] = 0;	/* change Video Base to 1Mb */	*((volatile unsigned char *)0x50F40008) = 0;	/* reset bit counter again */	fixed_eieio();	for (i=0; i<35; i++) {		*((volatile unsigned char *)0x50F40000) = savevalue[i];		fixed_eieio();	}}static voidget_string_property(RegEntryIDPtr entryID, char* prop_name, char *out_string){	OSErr					err;	RegPropertyValueSize	size;			size = MAX_STRING_PROP_SIZE-1;		err = RegistryPropertyGet(entryID, prop_name, out_string, &size);	if (err == noErr)		out_string[size] = 0;	else		out_string[0] = 0;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * This is a generic function that retrieves a property from the Name Registry, * allocating memory for it in the system pool. It looks in the Name Registry entry * for this driver -- the DriverInitializeCmd passed this as one of its parameters. * This sample is specific to device drivers: it allocates the property in the resident * memory pool. */OSStatusget_one_property(		RegEntryIDPtr			regEntryIDPtr,			/* Driver's Name Registery ID	*/		RegPropertyNamePtr		regPropertyName,		RegPropertyValue		*regPropertyValuePtr,		RegPropertyValueSize	*regPropertyValueSizePtr	){		OSStatus				status;		/*		 * In addition to getting the size of a property, this function will fail if		 * the property is not present in the registry. We NULL the result before		 * starting so we can dispose of the property even if this function failed.		 */		status = RegistryPropertyGetSize(					regEntryIDPtr,					regPropertyName,					regPropertyValueSizePtr				);		if (status == noErr) {			status = RegistryPropertyGet(						regEntryIDPtr,						regPropertyName,						regPropertyValuePtr,						regPropertyValueSizePtr					);			if (status != noErr)				dt_printf(dct, "RegistryPropertyGet failed (err:%d)\n", status);		}		return (status);}static PCIAssignedAddress	g_assigned_addresses[8];static LogicalAddress		g_logical_addresses[8];static UInt32count_assigned_addresses(RegEntryIDPtr entryID){	OSErr					err;	RegPropertyValueSize	size;	size = MAX_ASSIGNED_ADDRESSES * sizeof(PCIAssignedAddress);	err = RegistryPropertyGet(entryID, kPCIAssignedAddressProperty, g_assigned_addresses, &size);	if (err == noErr)		return size/sizeof(PCIAssignedAddress);	else		return 0;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * GetDeviceLogicalAddress * * Retrieve the assigned-address property from the Name Registry and search it for * the specified addressSpaceSelector. This function uses the device base register * only: it ignores the I/O vs. Memory space selector. It will need modification if * the hardware supports 64-bit addressing or needs to understand address spaces. */OSStatusget_logical_address(		RegEntryIDPtr			regEntryIDPtr,			/* Driver's Name Registery ID	*/		PCIRegisterNumber		deviceRegister,			/* Register in address property	*/		LogicalAddress			*deviceLogicalAddress,	/* Gets the logical address		*/		ByteCount				*deviceAreaLength		/* Gets the area size			*/	){		OSStatus				status;		UInt32					i;						/* Vector index					*/		UInt32					nAddresses;				/* Number of vector elements	*/		RegPropertyValueSize	assignedAddressSize;		RegPropertyValueSize	logicalAddressSize;		PCIAssignedAddressPtr	pciAssignedAddressPtr;	/* Assigned Address element ptr	*/		StringPtr				failureMsg;				failureMsg				= NULL;				if (deviceLogicalAddress == NULL)			status = paramErr;		else {			/*			 * Fetch the assigned address and AAPL,address properties. Allocate memory			 * for each.			 */			status = get_one_property(						regEntryIDPtr,						kPCIAssignedAddressProperty,						(RegPropertyValue*)g_assigned_addresses,						&assignedAddressSize);			if (status != noErr)				dt_printf(dct, "No assigned-addresses property (err: %d)\n", status);		}		if (status == noErr) {#define kAAPLDeviceLogicalAddress	"AAPL,address"			status = get_one_property(						regEntryIDPtr,						kAAPLDeviceLogicalAddress,						(RegPropertyValue*)g_logical_addresses,						&logicalAddressSize					);			if (status != noErr)				dt_printf(dct, "No AAPL,address property (err: %d)\n", status);		}		if (status == noErr) {			status					= paramErr;			nAddresses				= assignedAddressSize / sizeof (PCIAssignedAddress);			pciAssignedAddressPtr	= (PCIAssignedAddressPtr) g_assigned_addresses;						for (i = 0; i < nAddresses; i++, pciAssignedAddressPtr++) {				if (GetPCIRegisterNumber(pciAssignedAddressPtr) == deviceRegister) {					if (pciAssignedAddressPtr->size.hi != 0			/* 64-bit area?		*/					 || pciAssignedAddressPtr->size.lo == 0)					 {												/* Zero length		*/						/*						 * Open Firmware was unable to assign a valid address to this						 * memory area. We must return an error to prevent the driver						 * from starting up. Is there a better error status?						 */						status = paramErr;					}					else if (i >= (logicalAddressSize / sizeof (LogicalAddress))) {						/*						 * The logical address vector is too small -- this is a bug.						 */						status = paramErr;					}					else {						status = noErr;						*deviceLogicalAddress = g_logical_addresses[i];						if (deviceAreaLength)							*deviceAreaLength = pciAssignedAddressPtr->size.lo;					}					break; /* Exit loop when we find the desired register */				}			}			if (status != noErr)				dt_printf(dct, "No valid address space (err: %d)\n", status);		}		return (status);}static Booleancheck_vendor_device_id(RegEntryIDPtr entryID, UInt16 vendorID, UInt16 deviceID){	UInt32		pSize;	OSStatus	err;	UInt16		prop;		pSize = 2;	err = RegistryPropertyGet(entryID, "vendor-id", &prop, &pSize);	if ((err != noErr)||(pSize != 2))		return false;	if (prop != vendorID)		return false;	pSize = 2;	err = RegistryPropertyGet(entryID, "device-id", &prop, &pSize);	if ((err != noErr)||(pSize != 2))		return false;	return (prop == deviceID);}static SInt32read_pci_config_reg(RegEntryIDPtr entryID, int reg){	OSStatus	status;	UInt16		value;		status = ExpMgrConfigReadWord(entryID, (LogicalAddress)reg, &value);	if (status != noErr)		return -1;	return value;}voidreset_apple_DBDMA_channels(RegEntryIDPtr entryID){	char				prop[MAX_STRING_PROP_SIZE];	UInt32				addrs_count;	UInt32				*io_base;		get_string_property(entryID, "device_type", prop);	if (strcmp(prop, "dbdma") && strcmp(prop, "mac-io"))		return;		#if DEBUG	dt_printf(dct, "dbdma: ");#endif	addrs_count = count_assigned_addresses(entryID);	if (addrs_count < 1) {		dt_printf(dct, "dbdma: no addresses !\n");		return;	}	if (get_logical_address(entryID, 16, (LogicalAddress *)&io_base, NULL) != noErr) {		dt_printf(dct, "dbdma: can't get addresses !\n");		return;	}		if (io_base) {		int i;		io_base += 0x2000;	/* base of DBDMA channels */#if DEBUG		dt_printf(dct, "dbdma: io_base = 0x%x\n", io_base);#endif				for (i=0;i<16;i++) {			*(io_base) = 0x000000FCUL;			__eieio();			while((*(io_base+1)) & 0x00800000UL)				__eieio();		}	}#if DEBUG	else		dt_printf(dct, "dbdma: no io_base !\n");#endif		}voidreset_apple_SCSI_UW_board(RegEntryIDPtr entryID){	char				prop[MAX_STRING_PROP_SIZE];	Boolean				found = false;	Boolean				use_io = false;	char*				io_base;	SInt32				cmd;	UInt32				addrs_count;		get_string_property(entryID, "name", prop);	found = (strcmp(prop, "Apple53C875Card") == 0);	if (!found)		found = check_vendor_device_id(entryID, 0x1000, 0xf);	if (!found) {		return;	}#if DEBUG	dt_printf(dct, "symbios: ");#endif			cmd = read_pci_config_reg(entryID, kPCIConfigCommandAddress);	use_io = (cmd > 0) && (cmd & cwCommandEnableIOSpace);#if DEBUG	dt_printf(dct, "%s", use_io ? "(io) " : "(mem) ");#endif		addrs_count = count_assigned_addresses(entryID);	if (addrs_count < 2) {		dt_printf(dct, "symbios: not enough addresses !\n");		return;	}			if (use_io) {		if (get_logical_address(entryID, 16, (LogicalAddress *)&io_base, NULL) != noErr) {			dt_printf(dct, "symbios: can't get addresses !\n");			return;		}		if (!io_base) {#if DEBUG			dt_printf(dct, "symbios: no io range ->mem");#endif						use_io = false;		}	}	if (!use_io)		if (get_logical_address(entryID, 20, (LogicalAddress *)&io_base, NULL) != noErr) {			dt_printf(dct, "symbios: can't get addresses !\n");			return;		}	if (!io_base) {		dt_printf(dct, "symbios: no io base !");		return;	}#if DEBUG	dt_printf(dct, "symbios: base = 0x%x\n", io_base);#endif		*(io_base + 0x14) = 0x40;	__eieio();}voidreset_apple_USB(RegEntryIDPtr entryID){	char				prop[MAX_STRING_PROP_SIZE];	UInt32				addrs_count;	UInt32				*io_base;		get_string_property(entryID, "name", prop);	if (strcmp(prop, "usb"))		return;	get_string_property(entryID, "device_type", prop);	if (strcmp(prop, "usb"))		return;		#if DEBUG	dt_printf(dct, "usb: ");#endif	addrs_count = count_assigned_addresses(entryID);	if (addrs_count < 1) {		dt_printf(dct, "usb: not enough addresses !\n");		return;	}	if (get_logical_address(entryID, 16, (LogicalAddress *)&io_base, NULL) != noErr) {		dt_printf(dct, "usb:can't get addresses !\n");		return;	}	if (!io_base) {		dt_printf(dct, "usb: no io base !");		return;	}	#if DEBUG	dt_printf(dct, "usb: base = 0x%x\n", io_base);#endif		*(io_base + 0x02) = 0x01000000UL;	__eieio();}#define ATI_BUS_MSTR_RESET		0x00000002#define ATI_BUS_FLUSH_BUF		0x00000004#define ATI_BUS_CNTL			0x00a0#define ATI_GUI_ENGINE_ENABLE	0x0100#define ATI_GEN_TEST_CNTL		0x00d0#define ATI_BUS_HOST_ERR_ACK	0x00800000#define ATI_BUS_FIFO_ERR_ACK	0x00200000static inline void ati_regw(unsigned long base_addr, volatile unsigned long regindex, unsigned long regdata){  	__stwbrx(regdata, (void *)base_addr, (int)regindex);	__eieio();}static inline unsigned long ati_regr(unsigned long base_addr, volatile unsigned long regindex){	unsigned long val;  	  	val = __lwbrx((void *)base_addr, regindex);	__eieio();	return val;}voidreset_ATI_mach64_master(RegEntryIDPtr entryID){	char				prop[MAX_STRING_PROP_SIZE];	UInt32				addrs_count;	UInt32				base;	OSStatus			err;		get_string_property(entryID, "name", prop);	if (strncmp(prop, "ATY", 3))		return;	#if DEBUG	dt_printf(dct, "aty64: ");#endif	addrs_count = count_assigned_addresses(entryID);	switch(addrs_count) {		case 1:		case 2:		case 3:			err = get_logical_address(entryID, 16, (LogicalAddress *)&base, NULL);			break;		case 4:			err = get_logical_address(entryID, 20, (LogicalAddress *)&base, NULL);			break;		default:			dt_printf(dct, "aty64: bad address count !\n");			return;	}	if (!base || (err != noErr)) {		dt_printf(dct, "aty64: no address (err:%d) !\n", err);		return;	}		#if DEBUG	dt_printf(dct, "aty64: base = 0x%x\n", base);#endif	/* reset bus master */	ati_regw(base, ATI_BUS_CNTL, ati_regr(base, ATI_BUS_CNTL) | ATI_BUS_MSTR_RESET);	/* flush buffer, if bus mastering was memory <-> frame buffer */	ati_regw(base, ATI_BUS_CNTL, ati_regr(base, ATI_BUS_CNTL) | ATI_BUS_FLUSH_BUF);	/* reset graphic engine and clear errors, if bus mastering */	/* was memory -> command queue or HOST_DATA */	ati_regw(base, ATI_GEN_TEST_CNTL, ati_regr(base, ATI_GEN_TEST_CNTL) & ~ATI_GUI_ENGINE_ENABLE);	ati_regw(base, ATI_GEN_TEST_CNTL, ati_regr(base, ATI_GEN_TEST_CNTL) | ATI_GUI_ENGINE_ENABLE);	/* No effect for at least 3D RageLTPro, but an insurance. */	ati_regw(base, ATI_BUS_CNTL, ati_regr(base, ATI_BUS_CNTL) | ATI_BUS_HOST_ERR_ACK | ATI_BUS_FIFO_ERR_ACK);}		static OSErriterate_devices(iterate_device_proc	proc){	RegEntryIter			iterator;	RegEntryIterationOp		operation;	unsigned long			address = 0;	OSStatus				err;	Boolean					done;	char					buffer[1024];	char*					namePtr;		// Create an Iterator	operation = kRegIterRoot;		err = RegistryEntryIterateCreate(&iterator);		if (err == noErr) {		RegEntryID			entryID;		RegistryEntryIDInit(&entryID);		do {			RegPropertyValueSize pSize;						done = false;			err = RegistryEntryIterate(	&iterator,										operation,										&entryID,										&done);			if (operation == kRegIterRoot)				operation = kRegIterDescendants;			else if (operation == kRegIterDescendants)				operation = kRegIterContinue;			if (!done && (err == noErr))				proc(&entryID);		} while (!done && (err == noErr));		RegistryEntryIDDispose(&entryID);	}	if (err != noErr)		dt_printf(dct, "iterate failed with error %d\n", err);	err = RegistryEntryIterateDispose(&iterator);		return err;}