#include <Types.h>#include <Memory.h>#include <Errors.h>#include <Files.h>#include <Devices.h>#include <TextUtils.h>#include <LowMem.h>#include <a4Stuff.h>#include <Resources.h>#include "uLibc.h"#include "debug_text.h"#include "nr_wrapper.h"#include "zlib.h"#include "elf_loader_defs.h"#include "extract_dev_tree.h"#include "bootx.h"#include "LowLevelBoot.h"#include "rs6000.h"#define DEBUG	0static Ptr 		load_kernel(Str255 file_name, UInt32 *out_size);static OSErr	gunzip(void *dst, int dstlen, unsigned char *src, int *lenp);static OSErr	check_elf_kernel(Ptr kernel, UInt32 *out_offset, UInt32 *out_real_size, UInt32 *out_entry);static void		do_boot(UInt8* gz_kernel, UInt32 gz_kernel_size, int flags,					char *kernel_args, UInt8* ramdisk, UInt32 ramdisk_size);static OSErr	build_pci_device_tree(Ptr* outDevTree, UInt32 *outDevTreeSize, UInt32 *outDispRegOff);static OSErr	make_resident(void* ptr, unsigned long size, Boolean contiguous);static void*	load_bootstrap(long mapSize, UInt32** outMapBegin,UInt32 *outTotalSize);static int		check_kernel_format(int *out_flags, UInt8 **kern, UInt32 *kern_size,					UInt8 **out_rd, UInt32 *out_rds);#define get_16be(x)	(*(unsigned short *)(x))#define get_32be(x)	(*(unsigned *)(x))UInt8*	get_physical(void* ptr);/* Globals */dt_context*	dct = NULL;UInt32 g_page_size = 4096;#define KERNEL_ELF		0x01#define KERNEL_XCOFF	0x02#define KERNEL_GZIPPED	0x04void main(dt_context *input_context){	Ptr	k;	UInt32 ks;	Handle cmd;	Str63 kern_name;		EnterCodeResource();	dct = input_context;	dt_printf(dct, "\nLow-level entry...\n");		dt_printf(dct, "Initialize Name Registry wrappers...\n");	init_nr_wrappers();	dt_printf(dct, "Loading kernel...\n");	GetIndString(kern_name, 128, 1);	k = load_kernel(kern_name, &ks);	if (k) {		int		flags;		UInt8	*rd, *kern;		UInt32	rds;				kern = (UInt8 *)k;		if (check_kernel_format(&flags, &kern, &ks, &rd, &rds) != noErr) {			dt_printf(dct, "Unknown kernel format\n");			DisposePtr(k);			goto fail;		}		cmd = GetResource('CMDL', 128);		if (cmd) {			DetachResource(cmd);			HLock(cmd);		}		do_boot(kern, ks, flags, cmd ? *cmd : NULL, rd, rds);		if (cmd)			DisposeHandle(cmd);		DisposePtr(k);	}fail:	dt_printf(dct, "Exiting...\n");	dispose_nr_wrappers();		ExitCodeResource();}Ptrload_kernel(Str255 file_name, UInt32 *out_size){	HParamBlockRec	pb;	short			rn;	Ptr				buffer;	SInt32			file_size;	OSErr			err;		buffer = NULL;		pb.fileParam.ioCompletion = NULL;	pb.fileParam.ioNamePtr = file_name;	pb.fileParam.ioVRefNum = -1;	pb.fileParam.ioDirID = 2;	pb.fileParam.filler1 = fsRdPerm;	err = PBHOpenSync(&pb);	if (err != noErr) {		dt_printf(dct, "open error %d!\n", err);		return NULL;	}	rn = pb.ioParam.ioRefNum;	err = GetEOF(rn, &file_size);	if ((err != noErr) || file_size == 0) {		dt_printf(dct, "Can't get eof ! (%d)\n", err);		goto bail;	}		*out_size = file_size;	buffer = NewPtr(file_size);	if (!buffer) {		dt_printf(dct, "failed\n");		goto bail;	}	dt_printf(dct, "Reading %ld Kbytes at 0x%lx...\n", file_size/1024, buffer);	pb.ioParam.ioCompletion = NULL;	pb.ioParam.ioRefNum = rn;	pb.ioParam.ioBuffer = buffer;	pb.ioParam.ioReqCount = file_size;	pb.ioParam.ioPosMode = fsFromStart;	pb.ioParam.ioPosOffset = 0;	pb.ioParam.ioMisc = 0;	err = PBReadSync((ParmBlkPtr)&pb);	if ((err != noErr) && (err != eofErr)) {		dt_printf(dct, "read error %d !\n", err);		DisposePtr(buffer);		buffer = NULL;		goto bail;	}	FSClose(rn);bail:		return buffer;}static void *zalloc(void *x, unsigned items, unsigned size){  	Ptr	p = NewPtr(size * items);  	  	if (!p)  		dt_printf(dct, "zalloc(%d bytes) failed (err: %d) !",  			(size*items), MemError());  	  	return p;}static voidzfree(void *x, void *addr, unsigned nb){	if (addr)		DisposePtr(addr);}#define HEAD_CRC	2#define EXTRA_FIELD	4#define ORIG_NAME	8#define COMMENT		0x10#define RESERVED	0xe0#define DEFLATED	8OSErrgunzip(void *dst, int dstlen, unsigned char *src, int *lenp){    z_stream s;    int r, i, flags;    /* skip header */    i = 10;    flags = src[3];    if (src[2] != DEFLATED || (flags & RESERVED) != 0) {		dt_printf(dct, "bad gzipped data\n");		return -1;    }    if ((flags & EXTRA_FIELD) != 0)	i = 12 + src[10] + (src[11] << 8);    if ((flags & ORIG_NAME) != 0)	while (src[i++] != 0)	    ;    if ((flags & COMMENT) != 0)	while (src[i++] != 0)	    ;    if ((flags & HEAD_CRC) != 0)	i += 2;    if (i >= *lenp) {		dt_printf(dct, "gunzip: ran out of data in header\n");		return -1;    }    s.zalloc = zalloc;    s.zfree = zfree;    r = inflateInit2(&s, -MAX_WBITS);    if (r != Z_OK) {		dt_printf(dct, "inflateInit2 returned %d\n", r);		return -1;    }    s.next_in = src + i;    s.avail_in = *lenp - i;    s.next_out = dst;    s.avail_out = dstlen;    r = inflate(&s, Z_FINISH);    if (r != Z_OK && r != Z_STREAM_END) {		dt_printf(dct, "inflate returned %d\n", r);		return -1;    }    *lenp = s.next_out - (unsigned char *) dst;    inflateEnd(&s);   	   	return noErr;}#define NAME_REGISTRY_MAX_SIZE		(200UL * 1024UL)			// 200Kb: Size pre-allocated for holding name registry#define BOOT_KERNEL_STACK_SIZE		65536						// initial stack#define PAGE_ALIGN(x)	((((UInt32)(x)) + g_page_size - 1) & (-g_page_size))#define LINE_ALIGN(x)	((((UInt32)(x)) + 32 - 1) & (-32))#define BI_OFFSET(x)	(offsets[x] - offsets[offset_bootinfo])	/* Indexes in offset array */enum{	offset_kernel = 0,	/* kernel itself, offset 0 */	offset_stack,		/* boot stack */	offset_bootinfo,	/* boot_info */	offset_arguments,	/* args line */	offset_color_map,	/* colormap setup by bootx */	offset_device_tree,	/* device tree */	offset_ramdisk,		/* optional ramdisk */	offset_unmangler,	/* unmangler (may be moved higher) */	offset_count};voiddo_boot(UInt8* gz_kernel, UInt32 gz_kernel_size, int flags,	char *kernel_args, UInt8* ramdisk, UInt32 ramdisk_size){	Ptr		 		saveBufPtr = LMGetBufPtr();	Ptr				curBufPtr;	OSStatus		err;	UInt32			offsets[offset_count];	Ptr				main_base;	UInt32			total_size;	Ptr				dev_tree;	UInt32			dev_tree_size;	UInt32			dev_tree_disp_off;	UInt32			real_kern_size;	int				uncomp_kern_size;	UInt32			kern_entry;	UInt32			kern_offset;	Ptr				kernel_loc;	void*			strap_entry;	UInt32			strap_phys_entry, strap_dest;	UInt32			boot_map_addr, strap_size;	UInt32			prec, args_len;	UInt32*			map_loc;	UInt32			main_base_phys;	Handle			boot_resource_PPC;	void*			boot_glue_PPC;	boot_infos_t*	bi;	static PPCRegisterList	regList;			/* Build the copy of the device tree */	dt_printf(dct, "Copying device tree...\n");	err = build_pci_device_tree(&dev_tree, &dev_tree_size, &dev_tree_disp_off);	if (err != noErr) {		dt_printf(dct, "build_pci_device_tree returned error %d\n", err);		return;	}	dt_printf(dct, "Device tree is %d bytes at 0x%lx\n", dev_tree_size, dev_tree);	/* We uncompress the kernel at bufPtr - 4M (should be enough). We need this	   in order to find out the uncompressed size	 */	LMSetBufPtr(curBufPtr = (saveBufPtr - 0x400000));	uncomp_kern_size = gz_kernel_size;	if (flags & KERNEL_GZIPPED) {		dt_printf(dct, "Unzipping kernel (@0x%lx)... ", gz_kernel);		err = gunzip(curBufPtr, 0x400000, (unsigned char *)gz_kernel, &uncomp_kern_size);		if (err != noErr) {			dt_printf(dct, "failed !\n");			DisposePtr(dev_tree);			goto fail;		}		dt_printf(dct, "%ld KByte.\n", uncomp_kern_size/1024);	} else		memcpy(curBufPtr, gz_kernel, uncomp_kern_size);	kernel_loc = curBufPtr;		/* Now that the kernel is uncompressed, we can "check" it and get it's real	   size, entry point, etc...	 */	real_kern_size = uncomp_kern_size;	if (flags & KERNEL_ELF) {		if (check_elf_kernel(kernel_loc, &kern_offset, &real_kern_size, &kern_entry) != noErr) {			dt_printf(dct, "check_elf_kernel failed !\n");			DisposePtr(dev_tree);			goto fail;		}	} else {		/* I've not been able to figure out where to find the memory footprint for		   the kernel in this case.		   We leave an arbitrary size of 2Mb after the kernel, this should be		   enough for all cases, but it's ugly :-(		   Also, we should handle the case where we are not dealing with an XCOFF entry		   (Cort will change the entrypoint).		 */		if (((UInt32 *)(kernel_loc))[2] != 0)			dt_printf(dct, "strange xcoff descriptor\n");		kern_entry = *(UInt32 *)(kernel_loc);		dt_printf(dct, "xcoff entry: 0x%x, kern size: %ld KBytes\n",			kern_entry, real_kern_size/1024);		real_kern_size += 0x200000;		kern_offset = 0;	}		/* We build the map of offsets. Note that unlike BootX, we don't build a map	   of the kernel. At this point, VM should not be initialised yet. We still have	   the theorical possibility that memory is fragmented, let's just hope it's not	   for now (may happen on Nubus machines and 68k).	 */	if (ramdisk == NULL)		ramdisk_size = 0;	if (kernel_args == NULL)		args_len = 0;	else		args_len = strlen(kernel_args)+1;	offsets[offset_kernel]		= 0;	offsets[offset_stack]		= prec = PAGE_ALIGN(real_kern_size);	offsets[offset_bootinfo]	= prec = PAGE_ALIGN(prec + BOOT_KERNEL_STACK_SIZE);	offsets[offset_arguments]	= prec = LINE_ALIGN(prec + sizeof(boot_infos_t));	offsets[offset_color_map]	= prec = LINE_ALIGN(prec + args_len);	offsets[offset_device_tree]	= prec = LINE_ALIGN(prec + BOOTX_COLORTABLE_SIZE);	offsets[offset_ramdisk]		= prec = PAGE_ALIGN(prec + dev_tree_size);	offsets[offset_unmangler]	= prec = PAGE_ALIGN(prec + ramdisk_size);	total_size = prec + g_page_size;	/* We do the final bufPtr allocation */	LMSetBufPtr(curBufPtr = (saveBufPtr - total_size - g_page_size));	main_base = (Ptr)PAGE_ALIGN(curBufPtr);	main_base_phys = (UInt32)get_physical(main_base);	memset(main_base + offsets[offset_stack], 0, BOOT_KERNEL_STACK_SIZE);		dt_printf(dct, "Main load base: 0x%x\n", main_base);		/* We move the kernel to it's final location */	memmove(main_base, kernel_loc + kern_offset, real_kern_size);		/* We setup the boot-info stucture and fill it */	bi = (boot_infos_t *)(main_base + offsets[offset_bootinfo]);	memset(bi, 0, sizeof(boot_infos_t));	bi->version					= BOOT_INFO_VERSION;	bi->compatible_version		= BOOT_INFO_COMPATIBLE_VERSION;	bi->machineID				= 0; /* FIXME ! (check if Gestalt is impl.) */	bi->architecture			= BOOT_ARCH_PCI; /* FIXME ! */	bi->totalParamsSize			= BI_OFFSET(offset_unmangler);	if (kernel_args) {		bi->kernelParamsOffset	= BI_OFFSET(offset_arguments);		memcpy(main_base + offsets[offset_arguments], kernel_args, args_len);	} else		bi->kernelParamsOffset	= 0;	/* Make room for the colormap and store the offset. This offset will be used or cleared	   when the display device infos are really gathered by the low-level booter */	bi->dispDeviceColorsOffset	= BI_OFFSET(offset_color_map);	/* Copy in the device tree */	bi->deviceTreeOffset			= BI_OFFSET(offset_device_tree);	bi->deviceTreeSize				= dev_tree_size;	bi->dispDeviceRegEntryOffset	= dev_tree_disp_off;	memcpy(main_base + offsets[offset_device_tree], dev_tree, dev_tree_size);	/* Copy the ramdisk */	if (ramdisk_size) {		dt_printf(dct, "Copying ramdisk (0x%x Kbytes)\n", ramdisk_size/1024);		memcpy(main_base + offsets[offset_ramdisk], ramdisk, ramdisk_size);		bi->ramDisk				= BI_OFFSET(offset_ramdisk);		bi->ramDiskSize			= ramdisk_size;	}	/* Load the pre-strap code that shuts down known devices	   to prevent them from bus mastering to main memory	 */	boot_resource_PPC = Get1Resource('BSTP', 129);	if (!boot_resource_PPC) {		err = ResError();		dt_printf(dct, "failed to load pre-strap, err: %d\n",err);		DisposePtr(dev_tree);		return;	}	DetachResource(boot_resource_PPC);	HLock(boot_resource_PPC);	// the map size is multiplied by 2 to make room for "temp" copy	// operations that will be generated when source pages overlap	// destination. It's then multiplied by 12 which is the size of	// an entry in the copy-table.	// We use a small map of 1 entry for now to just copy the whole	// block down to 0.	strap_entry = load_bootstrap(2*12, &map_loc, &strap_size);	if (!strap_entry) {		DisposeHandle(boot_resource_PPC);		DisposePtr(dev_tree);		return;	}	// Make the boostrap resident and contiguous	err = make_resident(strap_entry, strap_size+g_page_size, true);	if (err != noErr) {		DisposeHandle(boot_resource_PPC);		DisposePtr(dev_tree);		return;	}	// The boostrap will move itself just after the kernel.	// We just make sure that source and dest don't overlap	// itself or one of the kernel pages	strap_size			= PAGE_ALIGN(strap_size);	strap_phys_entry	= (UInt32)get_physical(strap_entry);	strap_dest			= strap_phys_entry;		if (strap_dest < offsets[offset_unmangler])		strap_dest = PAGE_ALIGN(offsets[offset_unmangler] + strap_size);	if ((strap_dest >= (main_base_phys - strap_size)) &&		(strap_dest < (main_base_phys + total_size)))		strap_dest = PAGE_ALIGN(main_base_phys + total_size);	if ((strap_dest >= (strap_phys_entry - strap_size)) &&		(strap_dest < (strap_phys_entry + strap_size)))		strap_dest = PAGE_ALIGN(strap_phys_entry + total_size);		boot_map_addr = strap_dest + ((UInt32)map_loc - (UInt32)strap_entry);		dt_printf(dct, "strap entry      : 0x%lx\n", strap_entry);	dt_printf(dct, "strap dest       : 0x%lx\n", strap_dest);	dt_printf(dct, "strap phys entry : 0x%lx\n", strap_phys_entry);	dt_printf(dct, "strap size       : 0x%lx\n", strap_size);	map_loc[0] = main_base_phys;	map_loc[1] = 0; /* g_load_base */	map_loc[2] = offsets[offset_unmangler];	map_loc[3] = 0;	map_loc[4] = 0;	map_loc[5] = 0;		regList.PC		= (unsigned long)strap_entry;	regList.GPR[1]	= 0/*g_load_base*/ + offsets[offset_stack] + BOOT_KERNEL_STACK_SIZE - 512;	// The stack for the kernel entry	regList.GPR[2]	= 1;													// r2 flag must be set to 1 by BootX 	regList.GPR[3]	= 'BooX';												// r3 contains 'BooX' ($426F6F58)	regList.GPR[4]	= 0/*g_load_base*/ + offsets[offset_bootinfo];			// r4 contains the boot infos ptr	regList.GPR[5]	= NULL; /*iMacHack;*/									// r5 NULL, replaced by low-bootsrap with map base of fb	regList.GPR[6]	= strap_phys_entry;										// r6 contains phys addr. of bootstrap	regList.GPR[7]	= strap_dest;											// r7 contains dest addr. of bootstrap	regList.GPR[8]	= strap_size;	regList.GPR[9]	= boot_map_addr;	regList.GPR[10]	= kern_entry + 0/* g_load_base*/ + offsets[offset_kernel];	regList.GPR[11]	= 0;	// -- Call the low-level PPC boot glue (returns a pointer to an UPP) --	//    this call will make sure the code fragment is prepared and returns a pointer	//    that can later be called by the 68k code	boot_glue_PPC = ((pascal void*(*)(void))(*boot_resource_PPC))();	low_boot(&regList, bi, boot_glue_PPC);	fail:	LMSetBufPtr(saveBufPtr);}OSErrbuild_pci_device_tree(Ptr* outDevTree, UInt32 *outDevTreeSize, UInt32 *outDispRegOff){	Ptr				devTree;	OSErr			err;		// First make a copy of the device tree.	devTree	= NewPtr(NAME_REGISTRY_MAX_SIZE);	if (devTree == NULL) {		err = MemError();		if (err == noErr) err = memFullErr;		dt_printf(dct, "Can't allocate room for name registry (%d)\n", err);		return err;	}	err = noErr;		*outDevTreeSize = NAME_REGISTRY_MAX_SIZE;	err = copy_device_tree(devTree, outDevTreeSize, outDispRegOff);	if (err != noErr && (*outDevTreeSize > NAME_REGISTRY_MAX_SIZE)) {		dt_printf(dct, "Device tree overflow ! Your machine is probably crashed now.\n");		DisposePtr(devTree);				return err;	} else if (err != noErr) {		dt_printf(dct, "Error %d while copying device tree !\n", err);		DisposePtr(devTree);			}		*outDevTree = devTree;		return noErr;	}OSErrcheck_elf_kernel(Ptr kernel, UInt32 *out_offset, UInt32 *out_real_size, UInt32 *out_entry){	OSErr		err;	long		nb;	int 		i;	Elf32_Ehdr	*e;	Elf32_Phdr	*p;	UInt32		total_file_size;	UInt32		offset, entry, load_loc;	UInt32		size, start;		offset = entry = size =0;	total_file_size = *out_real_size;	e = (Elf32_Ehdr *)kernel;		/* Check if it is an executable elf binary.	 */	err = -1;	if (!(e->e_ident[EI_MAG0] == ELFMAG0 && e->e_ident[EI_MAG1] == ELFMAG1 &&		  e->e_ident[EI_MAG2] == ELFMAG2 && e->e_ident[EI_MAG3] == ELFMAG3)) {		dt_printf(dct, "Kernel doesn't look like an ELF image !");		goto out;	}	if (e->e_ident[EI_CLASS] != ELFCLASS32		|| e->e_ident[EI_DATA] != ELFDATA2MSB) {		dt_printf(dct, "Kernel ELF image is wrong format (not PPC MSB 32) !");	    goto out;	}		/* Check in the program header */	p = (Elf32_Phdr *)(kernel + e->e_phoff);#define ADDRMASK	0x0fffffff	size = 0;	/* Scan through the program header	 * HACK:  We must return the _memory size of the kernel image, not the	 *        file size (because we have to leave room before other boot	 *	  infos. This code works as a side effect of the fact that	 *	  we have one section and vaddr == p_paddr	 */	for (i = 0; i < e->e_phnum; ++i, ++p) {	    if (p->p_type != PT_LOAD || p->p_offset == 0)			continue;	    if (size == 0) {			offset = p->p_offset;			size = p->p_memsz; /*p->p_filesz*/;			load_loc = p->p_vaddr & ADDRMASK;			dt_printf(dct, "size (1) : 0x%x\n", size);	    } else {			size = p->p_offset + p->p_memsz - offset;			dt_printf(dct, "size (2) : 0x%x\n", size);		}	}	if (size == 0) {		dt_printf(dct, "Can't find a loadable segment in the kernel image !\n");		goto out;	}	entry = (UInt32)(e->e_entry & ADDRMASK) - load_loc;		/* Fix coff entry */	start = *(UInt32 *)(kernel + offset + entry);    if ((start < load_loc) || (start >= (load_loc + size))		|| (((UInt32 *)(kernel + offset + entry))[2] != 0))		/* doesn't look like a procedure descriptor */		start = entry + load_loc;	entry = start - load_loc;		dt_printf(dct, "k_real_size: %d bytes\n", size);	dt_printf(dct, "k_offset   : %d bytes\n", offset);	dt_printf(dct, "k_entry_off: %d bytes\n", entry);	*out_real_size = size;	*out_offset = offset;	*out_entry = entry;	return 0; out: 	return -1;}/* Get the physical address, if possible, of a pointer. Note that * we fail silently since we _do_ fail sometimes, like for screen * base address. In this case, we just return the original pointer */UInt8*get_physical(void* ptr){	LogicalToPhysicalTable	table;	unsigned long			count;	OSErr					err;		table.logical.address	= ptr;	table.logical.count		= 1024;	count = sizeof( table ) / sizeof( MemoryBlock ) - 1;		err = GetPhysical( &table, &count );	if ( err != noErr)		return ptr;		return (UInt8 *)(table.physical[0].address);}/* Make a portion of memory resident. */OSErrmake_resident(void* ptr, unsigned long size, Boolean contiguous){	OSErr	err;		if (size % g_page_size)		size = size + g_page_size - (size % g_page_size);	err = contiguous ? LockMemoryContiguous(ptr, size) : LockMemory(ptr, size);bail:	if (err != noErr)		dt_printf(dct, "LockMemory%s failed, err: %d\n",			contiguous ? "Contiguous" : "", err);	return err;}void *load_bootstrap(long mapSize, UInt32** outMapBegin,UInt32 *outTotalSize){	Handle				krsrc;	OSErr				err;	CFragConnectionID	fragID;	Ptr					fragEntry, loc;	Str255				errStr;	UInt32				origSize, extOrigSize, newSize;		krsrc = GetResource('BSTP', 128);	if (!krsrc) {		dt_printf(dct, "Can't load boostrap resource, err: %d\n",			ResError());		goto error;	}	DetachResource(krsrc);	HUnlock(krsrc);	origSize = GetHandleSize(krsrc);	extOrigSize  = origSize;	extOrigSize += 0x00000FFFUL;	extOrigSize &= 0xFFFFF000UL;	mapSize  += 0x00000FFFUL;	mapSize  &= 0xFFFFF000UL;	/* we add a page size since we'll align things */	newSize	  = extOrigSize + mapSize + g_page_size;	/* we add another page since we make resident a bit more datas */	SetHandleSize(krsrc, newSize + g_page_size);	if (GetHandleSize(krsrc) != (newSize + g_page_size)) {		dt_printf(dct, "Can't resize boostrap, err: %d\n",			MemError());		DisposeHandle(krsrc);		goto error;	}	HLock(krsrc);		loc = *krsrc;	loc = (Ptr)PAGE_ALIGN(loc);	if (loc != *krsrc) {		dt_printf(dct, "Boostrap moved from 0x%lx to 0x%lx\n",			*krsrc, loc);		BlockMove(*krsrc, loc, origSize);	}	*outMapBegin = (UInt32*)(loc + extOrigSize);	*outTotalSize = newSize;		err = GetMemFragment(loc, origSize, "\pbootstrap", kPrivateCFragCopy, &fragID, &fragEntry, errStr);	if (err != noErr) {		dt_printf(dct, "Boostrap preparation failed, err: %d (%#s)\n",			err, errStr);		DisposeHandle(krsrc);		goto error;	}		return ((void **)fragEntry)[0];	error:	return NULL;}intcheck_kernel_format(int *out_flags, UInt8 **kern, UInt32 *kern_size,					UInt8 **out_rd, UInt32 *out_rds){	Elf32_Ehdr* e;	struct external_filehdr* xc;	UInt32 orig_size;	UInt8* orig_kern;	orig_kern = *kern;	orig_size = *kern_size;	*out_rd = NULL;	*out_rds = 0;		e = (Elf32_Ehdr *)orig_kern;	xc = (struct external_filehdr *)orig_kern;		/* Check if it is an executable elf binary. */	if (e->e_ident[EI_MAG0] == ELFMAG0 && e->e_ident[EI_MAG1] == ELFMAG1 &&		  e->e_ident[EI_MAG2] == ELFMAG2 && e->e_ident[EI_MAG3] == ELFMAG3) {		dt_printf(dct, "ELF kernel\n");		*out_flags = KERNEL_ELF;		return noErr;	}		/* Check if this is an xcoff */#define CHECK_MAGIC(xc,m) (get_16be(xc->f_magic) == (m))	if ((get_16be(xc->f_magic) == 0735) || (get_16be(xc->f_magic) == 0730)		|| (get_16be(xc->f_magic) == 0737)) {    	struct external_scnhdr *sp;	    struct external_scnhdr *isect, *rsect;	    int ns, oh, i;	    unsigned sa, len;	    void *dst;	    		dt_printf(dct, "XCOFF kernel (zImage)\n");		*out_flags = KERNEL_XCOFF | KERNEL_GZIPPED;	    ns = get_16be(xc->f_nscns);	    oh = get_16be(xc->f_opthdr);	    sp = (struct external_scnhdr *) (orig_kern + sizeof(struct external_filehdr) + oh);	    isect = rsect = NULL;	    for (i = 0; i < ns; ++i, ++sp) {			if (strcmp(sp->s_name, "image") == 0)			    isect = sp;			else if (strcmp(sp->s_name, "initrd") == 0)			    rsect = sp;	    }	    if (isect == NULL)			dt_printf(dct, "image section not found\n");		else {			*kern = orig_kern + get_32be(isect->s_scnptr);			*kern_size = get_32be(isect->s_size);			if (rsect != NULL) {				*out_rd = orig_kern + get_32be(rsect->s_scnptr);				*out_rds = get_32be(rsect->s_size);				dt_printf(dct, "ramdisk found, size: %dKb\n", *out_rds);			}			return noErr;		}	}		/* This could be a gzipped file */    if (orig_kern[2] == DEFLATED && (orig_kern[3] & RESERVED) == 0) {		dt_printf(dct, "gzipped kernel\n");		*out_flags = KERNEL_ELF | KERNEL_GZIPPED;		return noErr;    }		return -1;}